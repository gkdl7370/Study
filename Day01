[OOP 4대 요소 실전 적용]
OOP(Object-Oriented Programming)란?

데이터와 그 데이터를 처리하는 로직을 객체(Object)라는 단위로 묶어 시스템을 구축하는 방식이다.
시스템을 교체 가능한 부품(Component)들의 집합으로 만들어 유지보수 비용을 최소화하는 설계 전략이다.

OOP 4대 요소와 Data-Flux 실전 사례
① 추상화 (Abstraction)

개념: 복잡한 내부 구현은 숨기고 외부에는 핵심적인 기능(인터페이스)만 노출하는 것

실전 적용: ItemWriter 인터페이스 사용

구체적 예시: 스프링 배치는 BulkDataWriter가 내부적으로 JdbcTemplate을 쓰는지 JPA를 쓰는지 모른다. 오직 write()라는 추상화된 규격만 보고 실행

효과: 저장 기술을 변경해도 전체 배치 공정(JobConfig)은 수정할 필요가 없음

② 캡슐화 (Encapsulation)

개념: 객체의 데이터(상태)를 외부에서 함부로 조작하지 못하게 보호하고 오직 객체가 허락한 메서드를 통해서만 상태를 변경하게 만드는 것

실전 적용: DataPoint 엔티티의 무분별한 Setter 제거 및 의미 있는 비즈니스 메서드 노출

구체적 예시: DataPoint의 모든 필드를 private으로 닫고 Setter를 없앰 대신 dataPoint.updateValue(Double newValue)라는 메서드를 만들고 그 엔티티 내부 메서드 안에서 "음수면 예외를 발생"시키도록 로직을 작성함

효과: 시스템 내의 어떤 Service 클래스가 이 객체를 가져다 쓰더라도, 실수로 쓰레기 값(음수)을 넣는 휴먼 에러를 원천 차단할 수 있도록 수정

③ 상속 (Inheritance)

개념: 기존 클래스의 상태(필드)와 행위(메서드)를 물려받아 중복 코드를 제거하고 재사용성을 높이는 것

실전 적용: 공통 기능을 정의한 AbstractValidator (추상 클래스) 상속

구체적 예시: 모든 검증기에서 공통으로 사용하는 '에러 로그 기록'이나 '공통 에러 코드 변환' 기능은 부모 클래스인 AbstractValidator에 만들어 두고 NegativeValidator는 이를 상속(extends)받아 공통 기능은 그대로 가져다 씀 + 자신만의 핵심 검증 로직만 추가함

효과: 공통된 규격(isValid())을 공유하므로 새로운 규칙을 추가할 때 규격에 맞춰 로직만 구현하면 됨

④ 다형성 (Polymorphism)

개념: 하나의 인터페이스나 클래스가 상황에 따라 여러 가지 형태의 객체로 동작하는 것

실전 적용: Processor 내의 List<DataValidator> 주입

구체적 예시: Processor는 validators 리스트 안의 구체 타입을 모름 하지만 루프를 돌며 isValid()를 호출하면 각 객체가 자신만의 방식으로 검증을 수행함

효과: Processor 코드를 수정하지 않고도 새로운 검증 규칙을 확장 가능함

결론: 왜 유지보수 비용이 줄어드는가?

OOP 4대 요소는 코드 간 의존성(Coupling)을 낮추는 도구임

추상화와 다형성을 통해 부품 교체가 쉬워짐

캡슐화를 통해 오류 전파를 차단함

상속(또는 인터페이스 기반 구조)을 통해 재사용성을 높임

이 구조는 새로운 기능 추가나 기존 기능 수정 시 개발 비용을 낮추는 효과가 있음

[Data-Flux 수정 방안]

1. 아키텍처 핵심 전략: 투-트랙(Two-Track) 모델

시스템 목적에 따라 데이터 경로를 이원화하여 성능(Throughput)과 안정성(Consistency)을 분리 관리함

Batch Path: 엑셀 등 대량 데이터 적재용. 편리함(JPA)보다 효율(JDBC)을 선택한 성능 중심 경로

API Path: 실시간 데이터 수집용. 속도보다 데이터 무결성과 비즈니스 로직 보호를 우선시한 경로

2. 추상화의 구체적 적용

추상화는 구체적인 방법(How)을 숨기고 해야 할 일(What)만 정의하는 것

① 구조적 추상화: 인터페이스 (ItemWriter)

구체적 예시: 스프링 배치의 ItemWriter 인터페이스를 구현하여 BulkDataWriter를 만듦

효과: 스프링 배치는 내부 저장 기술(JdbcTemplate인지 JPA인지)을 모름 오직 write() 규격만 보고 실행함. 저장 기술을 바꿔도 상위 설정은 변경되지 않음

② 연산적 추상화: Java Stream (flatMap)

구체적 예시:

// 중첩된 리스트(List<List<DataPoint>>)를 1차원 리스트로 평탄화
List<DataPoint> allPoints = chunk.getItems().stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());

flatMap 내부 구현은 숨기고 “평탄화한다”는 의도만 표현함

효과: 복잡한 이중 for-loop라는 구체적 행위를 flatMap이라는 추상적 도구 뒤로 숨겨 코드 가독성을 높임

3. 책임 분리(Separation of Concerns)의 구체적 적용

하나의 클래스가 여러 책임을 갖지 않도록 기능을 분리하는 전략

① 가공과 검증의 분리 (Validator 패턴)

현상: Processor가 데이터 분해(1:24)와 유효성 검사(음수 체크 등)를 모두 수행하면 코드가 비대해짐

해결: 검증 로직을 별도 Validator 클래스로 분리함

예시:
// 1. 책임 정의 (Interface)
public interface DataValidator { boolean isValid(Double value); }

// 2. 개별 책임 구현 (Implementation)
@Component
public class NegativeValidator implements DataValidator { ... } // 음수 체크만 담당

// 3. 책임의 조립 (Processor)
// Processor는 "데이터 분해"에 집중하고, 검증은 주입받은 Validator 리스트에 위임
validators.stream().allMatch(v -> v.isValid(value));

Processor는 검증 로직을 직접 구현하지 않고 주입받은 Validator 리스트에 위임함.

② 인프라 오버헤드 분리 (Service vs Component)

@Service(무거운 간부: DataPointService): 트랜잭션 관리, DB 저장 등 비즈니스 워크플로우 책임을 가짐. 반복 호출 시 오버헤드가 발생할 수 있음

@Component(경량 도구: Validator): 순수 기능 판단 역할을 수행함. 배치 반복문 내부에서 사용하기 적합함

@Repository(창고 지기: JPA): JPA 영속성 컨텍스트를 가동함. 대량 적재 시 관리 비용이 증가할 수 있음

전략: 배치 경로에서는 무거운 Service 호출을 피하고 경량 Validator(@Component)만 사용하여 오버헤드를 최소화함.

4. 왜 JPA 대신 JDBC인가? (성능 리스크 관리)
JPA IDENTITY 전략 X

메커니즘: @GeneratedValue(strategy = GenerationType.IDENTITY)는 INSERT 이후에야 ID를 알 수 있음

결과: 데이터 건수만큼 DB와 통신이 발생할 수 있음 (100개를 넣으려면 자바 <-> DB 통신을 100번 왕복)

JDBC Batch Update O

메커니즘: jdbcTemplate.batchUpdate()로 데이터를 Chunk 단위로 모아 한 번에 전송함

효과: 여러 번의 Round-trip을 한 번으로 줄여 대량 적재 시 성능을 개선함 (100번 왕복할 일을 단 1번의 통신으로 해결)
